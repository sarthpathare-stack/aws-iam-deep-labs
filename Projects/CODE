#!/usr/bin/env python3
"""
SCP Policy Evaluator + Region Lockdown Engine
Author: AWS Security Team
Version: 1.0.0
Description: Evaluates AWS SCP policies against resource deployment requests
"""

import json
import re
from typing import Dict, List, Any, Optional, Tuple
from datetime import datetime
import ipaddress

class SCPEvaluator:
    def __init__(self):
        self.scp_policies = []
        self.region_lockdown_enabled = False
        self.allowed_regions = []
        self.resource_types = {
            'EC2': 'ec2:Instance',
            'S3': 's3:Bucket',
            'IAM': 'iam:Role',
            'RDS': 'rds:DBInstance',
            'Lambda': 'lambda:Function',
            'VPC': 'ec2:VPC'
        }
    
    def load_scp_from_file(self, filepath: str) -> bool:
        """Load SCP policies from a JSON file"""
        try:
            with open(filepath, 'r') as f:
                data = json.load(f)
            
            if isinstance(data, dict):
                self.scp_policies = [data]
            elif isinstance(data, list):
                self.scp_policies = data
            else:
                print("‚ùå Invalid SCP file format")
                return False
            
            print(f"‚úÖ Loaded {len(self.scp_policies)} SCP policies")
            self._analyze_region_restrictions()
            return True
            
        except FileNotFoundError:
            print(f"‚ùå File not found: {filepath}")
            return False
        except json.JSONDecodeError:
            print("‚ùå Invalid JSON format")
            return False
    
    def load_scp_from_string(self, scp_json: str) -> bool:
        """Load SCP policies from a JSON string"""
        try:
            data = json.loads(scp_json)
            if isinstance(data, dict):
                self.scp_policies = [data]
            elif isinstance(data, list):
                self.scp_policies = data
            else:
                return False
            
            self._analyze_region_restrictions()
            return True
        except:
            return False
    
    def _analyze_region_restrictions(self):
        """Analyze SCPs for region lockdown configurations"""
        self.allowed_regions = []
        self.region_lockdown_enabled = False
        
        for policy in self.scp_policies:
            statements = policy.get('Statement', [])
            if isinstance(statements, dict):
                statements = [statements]
            
            for stmt in statements:
                # Check for region deny statements
                if stmt.get('Effect', '').upper() == 'DENY':
                    condition = stmt.get('Condition', {})
                    if 'StringNotEquals' in condition:
                        region_cond = condition['StringNotEquals']
                        if 'aws:RequestedRegion' in region_cond:
                            self.region_lockdown_enabled = True
                            allowed = region_cond['aws:RequestedRegion']
                            if isinstance(allowed, str):
                                self.allowed_regions.append(allowed)
                            elif isinstance(allowed, list):
                                self.allowed_regions.extend(allowed)
    
    def evaluate_request(self, 
                         resource_type: str, 
                         action: str, 
                         region: str = None,
                         resource_arn: str = None,
                         principal_arn: str = None,
                         source_ip: str = None) -> Dict[str, Any]:
        """
        Evaluate a resource deployment request against loaded SCPs
        
        Args:
            resource_type: AWS resource type (e.g., 'ec2:Instance')
            action: AWS action (e.g., 'ec2:RunInstances')
            region: AWS region
            resource_arn: Full ARN of the resource
            principal_arn: ARN of the principal making the request
            source_ip: Source IP address (optional)
        
        Returns:
            Dictionary with evaluation results
        """
        
        request_details = {
            'resource_type': resource_type,
            'action': action,
            'region': region,
            'resource_arn': resource_arn,
            'principal_arn': principal_arn,
            'source_ip': source_ip,
            'timestamp': datetime.now().isoformat()
        }
        
        # Initialize result structure
        result = {
            'decision': 'ALLOWED',
            'reasons': [],
            'denying_rules': [],
            'warnings': [],
            'region_check': None,
            'request_details': request_details
        }
        
        # Check if we have policies loaded
        if not self.scp_policies:
            result['reasons'].append('No SCP policies loaded - default ALLOW')
            return result
        
        # Evaluate each policy
        for policy_idx, policy in enumerate(self.scp_policies):
            policy_name = policy.get('Name', f'Policy-{policy_idx}')
            statements = policy.get('Statement', [])
            
            if isinstance(statements, dict):
                statements = [statements]
            
            for stmt_idx, stmt in enumerate(statements):
                stmt_name = stmt.get('Sid', f'Statement-{stmt_idx}')
                evaluation = self._evaluate_statement(stmt, request_details)
                
                if evaluation['applies']:
                    if evaluation['effect'] == 'DENY':
                        result['decision'] = 'DENIED'
                        result['denying_rules'].append({
                            'policy': policy_name,
                            'statement': stmt_name,
                            'effect': 'DENY',
                            'condition_matches': evaluation['condition_matches'],
                            'reason': evaluation['reason']
                        })
                        result['reasons'].append(f"Denied by {policy_name}/{stmt_name}")
                    
                    elif evaluation['effect'] == 'ALLOW':
                        # Allow statements don't override explicit denies
                        if result['decision'] != 'DENIED':
                            result['reasons'].append(f"Allowed by {policy_name}/{stmt_name}")
        
        # Perform region lockdown check
        if region:
            region_check = self._check_region_lockdown(region)
            result['region_check'] = region_check
            
            if not region_check['allowed']:
                result['decision'] = 'DENIED'
                result['reasons'].append(f"Region restriction: {region_check['message']}")
                result['denying_rules'].append({
                    'policy': 'RegionLockdown',
                    'statement': 'GlobalRegionRestriction',
                    'effect': 'DENY',
                    'reason': region_check['message']
                })
        
        # Check for misconfigurations
        misconfigs = self._detect_misconfigurations()
        if misconfigs:
            result['warnings'].extend(misconfigs)
        
        # If no explicit deny and no region deny, request is allowed
        if result['decision'] == 'ALLOWED' and not result['denying_rules']:
            result['reasons'].append('No denying SCP rules matched - default ALLOW')
        
        return result
    
    def _evaluate_statement(self, statement: Dict, request: Dict) -> Dict[str, Any]:
        """Evaluate a single SCP statement against the request"""
        
        effect = statement.get('Effect', '').upper()
        action = statement.get('Action', [])
        resource = statement.get('Resource', ['*'])
        condition = statement.get('Condition', {})
        
        # Default result
        result = {
            'applies': False,
            'effect': effect,
            'condition_matches': {},
            'reason': ''
        }
        
        # Check if statement applies to this action
        action_applies = self._check_action_match(action, request['action'])
        if not action_applies:
            return result
        
        # Check if statement applies to this resource
        resource_applies = self._check_resource_match(resource, request['resource_arn'])
        if not resource_applies:
            return result
        
        # Check conditions
        condition_matches = self._check_conditions(condition, request)
        
        # Determine if statement applies
        applies = action_applies and resource_applies
        
        # For NotAction/NotResource logic
        not_action = statement.get('NotAction', [])
        not_resource = statement.get('NotResource', [])
        
        if not_action:
            not_action_applies = self._check_action_match(not_action, request['action'])
            applies = applies and not not_action_applies
        
        if not_resource:
            not_resource_applies = self._check_resource_match(not_resource, request['resource_arn'])
            applies = applies and not not_resource_applies
        
        result['applies'] = applies
        result['condition_matches'] = condition_matches
        
        if applies:
            result['reason'] = f"Matched Action: {request['action']}, Resource: {request['resource_arn'] or '*'}"
        
        return result
    
    def _check_action_match(self, pattern_list, action: str) -> bool:
        """Check if action matches the pattern"""
        if isinstance(pattern_list, str):
            pattern_list = [pattern_list]
        
        for pattern in pattern_list:
            # Convert wildcard to regex
            regex_pattern = pattern.replace('*', '.*').replace('?', '.')
            if re.match(f'^{regex_pattern}$', action):
                return True
        
        return False
    
    def _check_resource_match(self, pattern_list, resource_arn: str) -> bool:
        """Check if resource ARN matches the pattern"""
        if not resource_arn:
            return True  # If no specific resource, assume match
        
        if isinstance(pattern_list, str):
            pattern_list = [pattern_list]
        
        for pattern in pattern_list:
            if pattern == '*':
                return True
            
            # Convert ARN pattern to regex
            regex_pattern = pattern.replace('*', '.*').replace('?', '.')
            if re.match(f'^{regex_pattern}$', resource_arn):
                return True
        
        return False
    
    def _check_conditions(self, condition: Dict, request: Dict) -> Dict[str, bool]:
        """Check all conditions in the statement"""
        matches = {}
        
        for operator, conditions in condition.items():
            for key, value in conditions.items():
                # Handle different condition keys
                if key == 'aws:RequestedRegion':
                    matches[key] = request['region'] == value
                elif key == 'aws:SourceIp':
                    matches[key] = self._check_ip_range(request.get('source_ip'), value)
                elif key == 'aws:PrincipalArn':
                    matches[key] = self._check_arn_match(request.get('principal_arn'), value)
                elif key == 'ec2:Region':
                    matches[key] = request['region'] == value
                # Add more condition checks as needed
        
        return matches
    
    def _check_ip_range(self, source_ip: str, allowed_range) -> bool:
        """Check if source IP is within allowed range"""
        if not source_ip:
            return False
        
        try:
            ip = ipaddress.ip_address(source_ip)
            
            if isinstance(allowed_range, str):
                allowed_range = [allowed_range]
            
            for range_str in allowed_range:
                if '/' in range_str:
                    network = ipaddress.ip_network(range_str, strict=False)
                    if ip in network:
                        return True
                else:
                    if ip == ipaddress.ip_address(range_str):
                        return True
        except ValueError:
            return False
        
        return False
    
    def _check_arn_match(self, principal_arn: str, pattern) -> bool:
        """Check if principal ARN matches pattern"""
        if not principal_arn:
            return False
        
        if isinstance(pattern, str):
            pattern = [pattern]
        
        for p in pattern:
            if p == '*':
                return True
            if principal_arn == p:
                return True
            # Add wildcard matching if needed
        
        return False
    
    def _check_region_lockdown(self, region: str) -> Dict[str, Any]:
        """Check if region is allowed based on SCP restrictions"""
        if not self.region_lockdown_enabled:
            return {
                'allowed': True,
                'message': 'No region lockdown configured'
            }
        
        if not self.allowed_regions:
            return {
                'allowed': False,
                'message': 'Region lockdown enabled but no allowed regions specified'
            }
        
        if region in self.allowed_regions:
            return {
                'allowed': True,
                'message': f'Region {region} is in allowed list'
            }
        else:
            return {
                'allowed': False,
                'message': f'Region {region} is not in allowed regions: {self.allowed_regions}'
            }
    
    def _detect_misconfigurations(self) -> List[str]:
        """Detect potential SCP misconfigurations"""
        warnings = []
        
        for policy_idx, policy in enumerate(self.scp_policies):
            policy_name = policy.get('Name', f'Policy-{policy_idx}')
            statements = policy.get('Statement', [])
            
            if isinstance(statements, dict):
                statements = [statements]
            
            # Check for overly permissive statements
            for stmt in statements:
                # Check for Allow with Resource: "*"
                if stmt.get('Effect', '').upper() == 'ALLOW':
                    resource = stmt.get('Resource', [])
                    if resource == '*' or (isinstance(resource, list) and '*' in resource):
                        action = stmt.get('Action', [])
                        if action == '*' or (isinstance(action, list) and '*' in action):
                            warnings.append(f"‚ö†Ô∏è Overly permissive ALLOW statement in {policy_name}: Action=*, Resource=*")
            
            # Check for conflicting statements
            # (Implementation depends on specific requirements)
        
        return warnings
    
    def get_policy_summary(self) -> Dict[str, Any]:
        """Get summary of loaded policies"""
        return {
            'total_policies': len(self.scp_policies),
            'region_lockdown_enabled': self.region_lockdown_enabled,
            'allowed_regions': self.allowed_regions,
            'policy_names': [p.get('Name', 'Unnamed') for p in self.scp_policies]
        }


# Example SCP policies for testing
EXAMPLE_SCP = {
    "Version": "2012-10-17",
    "Statement": [
        {
            "Sid": "DenyAllOutsideUS",
            "Effect": "Deny",
            "Action": "*",
            "Resource": "*",
            "Condition": {
                "StringNotEquals": {
                    "aws:RequestedRegion": "us-east-1"
                }
            }
        },
        {
            "Sid": "DenyEC2InProd",
            "Effect": "Deny",
            "Action": "ec2:*",
            "Resource": "arn:aws:ec2:*:123456789012:instance/*",
            "Condition": {
                "StringEquals": {
                    "aws:ResourceTag/Environment": "prod"
                }
            }
        },
        {
            "Sid": "AllowSpecificActions",
            "Effect": "Allow",
            "Action": [
                "s3:GetObject",
                "s3:ListBucket"
            ],
            "Resource": "*"
        }
    ]
}


def main():
    """Main function with example usage"""
    print("=" * 60)
    print("SCP POLICY EVALUATOR + REGION LOCKDOWN ENGINE")
    print("=" * 60)
    
    # Initialize evaluator
    evaluator = SCPEvaluator()
    
    # Load example SCP
    evaluator.load_scp_from_string(json.dumps(EXAMPLE_SCP))
    
    # Get policy summary
    summary = evaluator.get_policy_summary()
    print(f"\nüìã Policy Summary:")
    print(f"   Total Policies: {summary['total_policies']}")
    print(f"   Region Lockdown: {'Enabled' if summary['region_lockdown_enabled'] else 'Disabled'}")
    if summary['allowed_regions']:
        print(f"   Allowed Regions: {summary['allowed_regions']}")
    
    # Test cases
    test_cases = [
        {
            'name': 'EC2 in allowed region',
            'resource_type': 'ec2:Instance',
            'action': 'ec2:RunInstances',
            'region': 'us-east-1',
            'resource_arn': 'arn:aws:ec2:us-east-1:123456789012:instance/i-12345'
        },
        {
            'name': 'EC2 in denied region',
            'resource_type': 'ec2:Instance',
            'action': 'ec2:RunInstances',
            'region': 'eu-west-1',
            'resource_arn': 'arn:aws:ec2:eu-west-1:123456789012:instance/i-12345'
        },
        {
            'name': 'S3 access in denied region',
            'resource_type': 's3:Bucket',
            'action': 's3:CreateBucket',
            'region': 'ap-south-1',
            'resource_arn': 'arn:aws:s3:::test-bucket'
        },
        {
            'name': 'Allowed S3 action',
            'resource_type': 's3:Bucket',
            'action': 's3:GetObject',
            'region': 'us-east-1',
            'resource_arn': 'arn:aws:s3:::test-bucket/object.txt'
        }
    ]
    
    print("\nüß™ Running Test Cases:")
    print("-" * 60)
    
    for test in test_cases:
        print(f"\nTest: {test['name']}")
        print(f"Request: {test['action']} in {test['region']}")
        
        result = evaluator.evaluate_request(
            resource_type=test['resource_type'],
            action=test['action'],
            region=test['region'],
            resource_arn=test['resource_arn']
        )
        
        print(f"Decision: {result['decision']}")
        
        if result['decision'] == 'DENIED':
            print("Reasons for DENY:")
            for reason in result['reasons']:
                print(f"  ‚Ä¢ {reason}")
            
            if result['denying_rules']:
                print("\nDenying Rules:")
                for rule in result['denying_rules']:
                    print(f"  ‚Ä¢ {rule['policy']}/{rule['statement']}: {rule['reason']}")
        else:
            print("Reasons for ALLOW:")
            for reason in result['reasons']:
                print(f"  ‚Ä¢ {reason}")
        
        if result['warnings']:
            print("\n‚ö†Ô∏è Warnings:")
            for warning in result['warnings']:
                print(f"  ‚Ä¢ {warning}")
        
        print("-" * 40)


def interactive_mode():
    """Interactive mode for manual testing"""
    evaluator = SCPEvaluator()
    
    print("\n" + "=" * 60)
    print("INTERACTIVE SCP EVALUATOR")
    print("=" * 60)
    
    # Load SCP file
    scp_file = input("Enter path to SCP JSON file (or press Enter for example): ").strip()
    
    if scp_file:
        if not evaluator.load_scp_from_file(scp_file):
            print("Using example SCP instead.")
            evaluator.load_scp_from_string(json.dumps(EXAMPLE_SCP))
    else:
        print("Using example SCP.")
        evaluator.load_scp_from_string(json.dumps(EXAMPLE_SCP))
    
    while True:
        print("\n" + "-" * 40)
        print("New Evaluation Request")
        print("-" * 40)
        
        action = input("AWS Action (e.g., 'ec2:RunInstances'): ").strip()
        region = input("AWS Region (e.g., 'us-east-1'): ").strip()
        resource_arn = input("Resource ARN (optional): ").strip()
        resource_type = input("Resource Type (optional): ").strip()
        
        if not resource_type:
            # Try to infer from ARN or action
            if 'ec2' in action.lower():
                resource_type = 'ec2:Instance'
            elif 's3' in action.lower():
                resource_type = 's3:Bucket'
            else:
                resource_type = 'aws:Resource'
        
        result = evaluator.evaluate_request(
            resource_type=resource_type,
            action=action,
            region=region,
            resource_arn=resource_arn if resource_arn else None
        )
        
        print("\n" + "=" * 40)
        print("EVALUATION RESULT")
        print("=" * 40)
        print(f"Decision: {result['decision']}")
        print(f"Region Check: {result['region_check']['message'] if result['region_check'] else 'N/A'}")
        
        print("\nReasons:")
        for reason in result['reasons']:
            print(f"  ‚Ä¢ {reason}")
        
        if result['denying_rules']:
            print("\nDenying Rules:")
            for rule in result['denying_rules']:
                print(f"  ‚Ä¢ {rule['policy']}/{rule['statement']}")
                print(f"    Reason: {rule['reason']}")
        
        if result['warnings']:
            print("\n‚ö†Ô∏è Warnings:")
            for warning in result['warnings']:
                print(f"  ‚Ä¢ {warning}")
        
        continue_eval = input("\nEvaluate another request? (y/n): ").strip().lower()
        if continue_eval != 'y':
            break
    
    print("\nThank you for using SCP Policy Evaluator!")


if __name__ == "__main__":
    # Run example tests
    main()
    
    # Uncomment to run interactive mode
    # interactive_mode()